#!/usr/bin/env bash

source parse.sh

# Take the path to a cachegrind file generated by cg_annotate, and the
# function to be processed, and extract the general stats about it.
cachegrind::process_fn() {
    local cg=$1
    local fn=$2

    sed -n "/:${fn}$/ s/\/.*//p" ${cg} \
        | sed "s/([^)]*)//g" \
        | sed "s/^[[:blank:]]*//" \
        | sed "s/[[:blank:]]*$//" \
        | sed "s/,/./g" \
        | sed -E "s/[[:blank:]]+/,/g"
}

# Takes the path to a benchmark and filter the cachegrind stats collected by
# cachegrind::run to produce CSV files containing the results for specific
# functions. This function assumes the existence of three cachegrind files
# (generated by cg_annotate) for each source file (original, isochronous and
# isochr-optimized).
cachegrind::filter() {
    local bench=$1;
    local results=${bench}/results
    local sources=${bench}/src

    # Parse the bench/meta.yaml file to get the name of the functions and
    # the cache config.
    local -A meta
    parse::yaml ${bench}/meta.yaml meta
    local -a fns=(${meta[functions]//,/ })
    local -a cache=($(echo ${meta[cache]//,/ } | sed "s/;/,/g"))

    # Get the src files and collect data for each one.
    local -a srcs=($(ls $sources | grep "main"))

    # We assume that the collected evens are the same for all sources, so we
    # can take them from cachegrind file related to the first source.
    local cg=${results}/$(echo ${srcs[0]} | sed "s/\.[^.]*$//")
    local events=$(sed -n "s/Events shown:[[:blank:]]*//p" ${cg}.cachegrind | sed "s/ /,/g")

    # Generate a CSV file for the cachegrind data.
    echo "Src,Fn,Type,$events" > ${results}/cachegrind.csv

    for src in ${srcs[@]}; do
        cg=${results}/$(echo $src | sed "s/\.[^.]*$//")

        for fn in ${fns[@]}; do
            local data=$(cachegrind::process_fn ${cg}.cachegrind $fn)
            if [ -z $data ]; then continue; fi
            echo "${src},${fn},orig,$data" >> ${results}/cachegrind.csv

            data=$(cachegrind::process_fn ${cg}.opt.cachegrind $fn)
            echo "${src},${fn},orig-opt,$data" >> ${results}/cachegrind.csv

            data=$(cachegrind::process_fn ${cg}_isochr.cachegrind $fn)
            echo "${src},${fn},isochr,$data" >> ${results}/cachegrind.csv

            data=$(cachegrind::process_fn ${cg}_isochr.opt.cachegrind $fn)
            echo "${src},${fn},isochr-opt,$data" >> ${results}/cachegrind.csv
        done
    done

    echo "Generated cachegrind CSV file: ${bench}/results/cachegrind.csv"
}

# Takes the path to a benchmark and runs the cachegrind tool on each binary
# inside a "bin" folder (generated by build.sh).
cachegrind::run() {
    local bench=$1;
    local bin=${bench}/bin
    local results=${bench}/results

    # Create results folder if it doesn't exist.
    mkdir -p $results

    # Parse the meta.yaml file to extract the cache configuration.
    local -A meta
    parse::yaml ${bench}/meta.yaml meta
    local -a cache=($(echo ${meta[cache]//,/ } | sed "s/;/,/g"))

    # Run cachegrind on each generated executable in order to check the number
    # of instructions executed, and measure cache-hits and cache-misses.
    for binname in $(ls $bin | grep "main"); do
        valgrind --tool=cachegrind ${cache[0]} ${cache[1]} ${cache[2]} \
            --cachegrind-out-file=tmp.cachegrind "${bin}/${binname}" &> /dev/null
        cg_annotate --threshold=0 tmp.cachegrind > "${results}/${binname}.cachegrind"
    done

    rm tmp.cachegrind
}
